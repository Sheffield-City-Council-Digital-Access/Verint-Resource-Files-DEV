name: Replace File on Server

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: 'Path to file in repository (e.g., scripts/main.js)'
        required: true
        type: string
      environment:
        description: 'Select the target environment'
        required: true
        type: choice
        default: 'dev'
        options:
          - dev
          - qa
          - prod

jobs:
  update-file:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set API Base URL
        run: |
          case "${{ github.event.inputs.environment }}" in
            "dev")
              echo "API_BASE_URL=${{ secrets.VERINT_API_URL_DEV }}" >> $GITHUB_ENV
              ;;
            "qa")
              echo "API_BASE_URL=${{ secrets.VERINT_BASE_URL_QA }}" >> $GITHUB_ENV
              ;;
            "prod")
              echo "API_BASE_URL=${{ secrets.VERINT_BASE_URL_PROD }}" >> $GITHUB_ENV
              ;;
          esac
      
      - name: Determine Content Type
        id: set_content_type
        run: |
          FILE_PATH="${{ github.event.inputs.file_path }}"
          FILE_EXT="${FILE_PATH##*.}"
          
          case "$FILE_EXT" in
            js)
              CONTENT_TYPE="text/javascript"
              ;;
            css)
              CONTENT_TYPE="text/css"
              ;;
            png)
              CONTENT_TYPE="image/png"
              ;;
            svg)
              CONTENT_TYPE="image/svg+xml"
              ;;
            *)
              CONTENT_TYPE="text/plain"
              ;;
          esac
          
          echo "📄 Determined Content-Type: $CONTENT_TYPE"
          echo "content_type=$CONTENT_TYPE" >> $GITHUB_OUTPUT

      - name: Extract file properties
        id: file_props
        run: |
          echo "🔍 DEBUG: Starting validation and environment check..."
          
          FILE_PATH="${{ github.event.inputs.file_path }}"
          if [ ! -f "$FILE_PATH" ]; then
            echo "❌ DEBUG: File not found: $FILE_PATH"
            echo '{"status": "failed", "error": "File not found"}' > update_response.json
            exit 1
          else
            echo "✅ DEBUG: File found: $FILE_PATH"
          fi
          
          FILENAME=$(basename "$FILE_PATH")
          DIR_PATH=$(dirname "$FILE_PATH")
          
          if [ "$DIR_PATH" = "." ]; then
            FOLDER_NAME="root"
            echo "DEBUG: File is in root directory, setting folder name to 'root'"
          else
            FOLDER_NAME=$(basename "$DIR_PATH")
            echo "DEBUG: Extracted folder name: '$FOLDER_NAME'"
          fi

          echo "FILENAME=$FILENAME" >> $GITHUB_ENV
          echo "FOLDER_NAME=$FOLDER_NAME" >> $GITHUB_ENV
      
      - name: Find File Key on Server
        env:
          API_USERNAME: ${{ secrets.VERINT_USERNAME }}
          API_PASSWORD: ${{ secrets.VERINT_PASSWORD }}
        run: |
          echo "🔍 Searching for existing file key for '$FILENAME' in folder '$FOLDER_NAME'..."
          
          response_get=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -u "${API_USERNAME}:${API_PASSWORD}" \
            "${API_BASE_URL}/files?query=${FILENAME}" 2>/dev/null || echo "HTTPSTATUS:000")
          
          get_body=$(echo "$response_get" | sed -E 's/HTTPSTATUS\:[0-9]{3}$//')
          http_status=$(echo "$response_get" | sed -E 's/.*HTTPSTATUS:([0-9]{3})$/\1/')

          if [ "$http_status" -ne 200 ]; then
            echo "❌ Failed to query for file key. HTTP Status: $http_status"
            echo "Response: $get_body"
            exit 1
          fi

          # Use a more robust jq query to find the key based on filename and folder
          if [ "$FOLDER_NAME" = "root" ]; then
            # Handle files in the root folder, which may have a null or empty folderName
            FILE_KEY=$(echo "$get_body" | jq -r --arg FILENAME "$FILENAME" \
              '.collection[] | select(.fileName == $FILENAME and (.folderName == null or .folderName == "")) | .key // empty')
          else
            # Handle files in a subfolder
            FILE_KEY=$(echo "$get_body" | jq -r --arg FILENAME "$FILENAME" --arg FOLDER_NAME "$FOLDER_NAME" \
              '.collection[] | select(.fileName == $FILENAME and .folderName == $FOLDER_NAME) | .key // empty')
          fi

          if [ -z "$FILE_KEY" ]; then
            echo "❌ File key not found for '$FILENAME' in folder '$FOLDER_NAME'. Cannot update file."
            echo '{"status": "failed", "error": "File to update not found on server"}' > update_response.json
            exit 1
          else
            echo "✅ Found file key: $FILE_KEY"
            echo "FILE_KEY=$FILE_KEY" >> $GITHUB_ENV
          fi

      - name: Update File on Server
        env:
          API_USERNAME: ${{ secrets.VERINT_USERNAME }}
          API_PASSWORD: ${{ secrets.VERINT_PASSWORD }}
          FILE_PATH: ${{ github.event.inputs.file_path }}
          CONTENT_TYPE: ${{ steps.set_content_type.outputs.content_type }}
        run: |
          echo "🔍 DEBUG: Starting file update..."
          
          if [ -z "$FILE_KEY" ]; then
            echo "❌ FILE_KEY is empty. Cannot proceed with update."
            exit 1
          fi

          echo "DEBUG: Update parameters:"
          echo "  - File Key: $FILE_KEY"
          echo "  - File Path: $FILE_PATH"
          echo "  - Content Type: $CONTENT_TYPE"
          echo "  - API Base URL: $API_BASE_URL"
          
          response_put=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -X 'PUT' \
            "${API_BASE_URL}/files/${FILE_KEY}" \
            -H 'accept: application/json' \
            -u "${API_USERNAME}:${API_PASSWORD}" \
            -H 'Content-Type: multipart/form-data' \
            -F "file=@${FILE_PATH};type=${CONTENT_TYPE}" 2>/dev/null || echo "HTTPSTATUS:000")
            
          http_status=$(echo "$response_put" | sed -E 's/.*HTTPSTATUS:([0-9]{3})$/\1/')
          put_body=$(echo "$response_put" | sed -E 's/HTTPSTATUS\:[0-9]{3}$//')
          
          if [ "$http_status" -eq 200 ]; then
            echo "✅ File update successful! Response: $put_body"
            echo '{"status": "success", "message": "File updated successfully"}' > update_response.json
          else
            echo "❌ File update failed with status $http_status. Response: $put_body"
            echo '{"status": "failed", "error": "API response indicates failure"}' > update_response.json
            exit 1
          fi
          
      - name: Upload response as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-update-response-${{ github.run_number }}
          path: |
            update_response.json
            ${{ github.event.inputs.file_path }}
          retention-days: 7
