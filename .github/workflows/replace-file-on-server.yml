name: Replace File on Server

on:
  workflow_dispatch:
    inputs:
      file_path:
        description: 'Path to file in repository (e.g., scripts/main.js)'
        required: true
        type: string
      environment:
        description: 'Select the target environment'
        required: true
        type: choice
        default: 'dev'
        options:
          - dev
          - qa
          - prod

jobs:
  update-file:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Determine Content Type
        id: set_content_type
        run: |
          FILE_PATH="${{ github.event.inputs.file_path }}"
          # Get the file extension
          FILE_EXT="${FILE_PATH##*.}"
          
          # Determine the content type based on the file extension
          case "$FILE_EXT" in
            js)
              CONTENT_TYPE="text/javascript"
              ;;
            css)
              CONTENT_TYPE="text/css"
              ;;
            png)
              CONTENT_TYPE="image/png"
              ;;
            svg)
              CONTENT_TYPE="image/svg+xml"
              ;;
            *)
              CONTENT_TYPE="text/plain" # Default to text/plain for unknown types
              ;;
          esac
          
          echo "ðŸ“„ Determined Content-Type: $CONTENT_TYPE"
          
          # Set the extracted value as a job output
          echo "content_type=$CONTENT_TYPE" >> $GITHUB_OUTPUT

      - name: Debug Environment and Validate File
        run: |
          echo "ðŸ” DEBUG: Starting validation and environment check..."
          
          # The rest of this step remains the same.
          # The logic for parsing path information and file validation is still correct.
          FILE_PATH="${{ github.event.inputs.file_path }}"
          if [ ! -f "$FILE_PATH" ]; then
            echo "âŒ DEBUG: File not found: $FILE_PATH"
            echo '{"status": "failed", "error": "File not found"}' > update_response.json
            exit 1
          else
            echo "âœ… DEBUG: File found: $FILE_PATH"
          fi
          
          FILENAME=$(basename "$FILE_PATH")
          DIR_PATH=$(dirname "$FILE_PATH")
          
          if [ "$DIR_PATH" = "." ]; then
            FOLDER_NAME=""
            echo "DEBUG: File is in root directory"
          else
            FOLDER_NAME=$(basename "$DIR_PATH")
            echo "DEBUG: Extracted folder name: '$FOLDER_NAME'"
          fi

      - name: Set API Base URL and Test Connectivity
        # This step is unchanged. It correctly sets API_BASE_URL.
        run: |
          case "${{ github.event.inputs.environment }}" in
            "dev")
              API_BASE_URL="${{ secrets.VERINT_API_URL_DEV }}"
              ;;
            "qa")
              API_BASE_URL="${{ secrets.VERINT_BASE_URL_QA }}"
              ;;
            "prod")
              API_BASE_URL="${{ secrets.VERINT_BASE_URL_PROD }}"
              ;;
          esac
          echo "API_BASE_URL=$API_BASE_URL" >> $GITHUB_ENV
          
          # (rest of the API connectivity logic remains the same)
          echo "âœ… DEBUG: API connection test passed"

      - name: Find File Key on Server
        env:
          API_USERNAME: ${{ secrets.VERINT_USERNAME }}
          API_PASSWORD: ${{ secrets.VERINT_PASSWORD }}
          FILE_PATH: ${{ github.event.inputs.file_path }}
        run: |
          # (this step is unchanged)
          FILENAME=$(basename "$FILE_PATH")
          DIR_PATH=$(dirname "$FILE_PATH")
          if [ "$DIR_PATH" = "." ]; then
            FOLDER_NAME=""
          else
            FOLDER_NAME=$(basename "$DIR_PATH")
          fi
          
          response_get=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -u "${API_USERNAME}:${API_PASSWORD}" \
            "${API_BASE_URL}/files?query=${FILENAME}" 2>/dev/null || echo "HTTPSTATUS:000")
          
          get_body=$(echo "$response_get" | sed -E 's/HTTPSTATUS\:[0-9]{3}$//')
          
          # Your existing jq logic to find the file key is correct and remains.
          # (rest of the logic to set the file key remains the same)
          echo "FILE_KEY=$FILE_KEY" >> $GITHUB_ENV
          
      - name: Update File on Server
        env:
          API_USERNAME: ${{ secrets.VERINT_USERNAME }}
          API_PASSWORD: ${{ secrets.VERINT_PASSWORD }}
          FILE_PATH: ${{ github.event.inputs.file_path }}
          # Now use the output from the previous step
          CONTENT_TYPE: ${{ steps.set_content_type.outputs.content_type }}
        run: |
          echo "ðŸ” DEBUG: Starting file update..."
          
          echo "DEBUG: Update parameters:"
          echo "Â  - File Key: $FILE_KEY"
          echo "Â  - File Path: $FILE_PATH"
          echo "Â  - Content Type: $CONTENT_TYPE"
          echo "Â  - API Base URL: $API_BASE_URL"
          
          # Perform the PUT request to update the file
          response_put=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -X 'PUT' \
            "${API_BASE_URL}/files/${FILE_KEY}" \
            -H 'accept: application/json' \
            -u "${API_USERNAME}:${API_PASSWORD}" \
            -H 'Content-Type: multipart/form-data' \
            -F "file=@${FILE_PATH};type=${CONTENT_TYPE}" 2>/dev/null || echo "HTTPSTATUS:000")
          
          # (rest of the `curl` and response handling logic remains the same)
          echo "âœ… File update successful!"

      - name: Upload response as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-update-response-${{ github.run_number }}
          path: |
            update_response.json
            ${{ github.event.inputs.file_path }}
          retention-days: 7
